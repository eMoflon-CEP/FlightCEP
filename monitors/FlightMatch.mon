//*****************************************************************************
// Title:         FlightMatch
// Description:   FlightMatch description
// Dependencies:  None
// Author:        Konrad Altenhofen
//
//*****************************************************************************



// TODO: Monitors and event definitions here

monitor FlightMatch {
	constant string eventChannel := "eMoflonPatternMatch";
	constant string outputChannel := "eMoflonTalkback";
	/**
	 *  Temp events for further processing
	 */
	TravelHasConnectingFlightMatchEvent travelHasConnectingFlight;
	ConnectingFlightAlternativeMatchEvent connectingFlightAlternative;
	FlightMatchEvent flightWithRoute;
	FlightDelayed delayed;
	TravelHasNotReachableConnectingFlight notReachableTravelCF;
	/**
	 *  Persons currently on a plane, plane capacity and best alternative flight
	 */
	dictionary<string, integer> personsOnFlightDict;
	dictionary<string, integer> flightCapacityDict;
	dictionary<string, ConnectingFlightAlternativeMatchEvent> alternativeForConnectingFlightDict;
	integer serviceLevel;
	integer numberDelayedConnectingFlights;
	integer numberWorkingConnectingFlights;
	boolean isReach;

	action onload() {
		// init dictionarys
		personsOnFlightDict := new dictionary<string, integer>;
		flightCapacityDict := new dictionary<string, integer>;
		alternativeForConnectingFlightDict := new dictionary<string, ConnectingFlightAlternativeMatchEvent>;
		numberDelayedConnectingFlights := 0;
		numberWorkingConnectingFlights := 0;
		// subscribe to event channel
		monitor.subscribe(eventChannel);
		
		on ServiceLevel("Test") {
			log "<DEBUG> Serice Level: Test
				eventChannel: " + eventChannel +
				"outputChannel: " + outputChannel at INFO;
			serviceLevel := 2;
		}
		
		on ServiceLevel("Test") -> all RequestWorkingConnectingFlights() as request {
			log "<DEBUG> Received request for working ConnectingFlights: " + numberWorkingConnectingFlights.toString() at INFO;
			send SendWorkingConnectingFlights(request.messageID ,numberWorkingConnectingFlights) to eventChannel;
		}
		on ServiceLevel("Test") -> all RequestDelayedConnectingFlights() as request {
			log "<DEBUG> Received request for delayed ConnectingFlights " + numberDelayedConnectingFlights.toString() at INFO;
			send SendDelayedConnectingFlights(request.messageID, numberDelayedConnectingFlights) to eventChannel;
		}
		
		/**
		 *  Is flight delayed?
		 */
		on all FlightMatchEvent():flightWithRoute checkDelayedFlight();
		/**
		 *  Has flight better alternative connecting flight?
		 */
		on all ConnectingFlightAlternativeMatchEvent(): connectingFlightAlternative {
			on TravelHasConnectingFlightMatchEvent(flightID=connectingFlightAlternative.flightID):
		        travelHasConnectingFlight
			   and all FlightHasFreeSpaces (flightID=connectingFlightAlternative.replacementFlightID)
	        	-> not FlightIsFull(flightID=connectingFlightAlternative.replacementFlightID) updateAlternative();
		}
			
		/**
		 *  Update persons currently on flight 
		 */
		on all TravelWithFlightMatchEvent() as flightInTravel {
			addPersonToFlight(flightInTravel.flightID, flightInTravel.planeCapacity, 1);
		}
		on all TravelWithFlightMatchRemovedEvent() as flightInTravel {
			removePersonFromFlight(flightInTravel.flightID, 1);
		}
		/**
		 *  Connecting-Flight not reachable
		 */
		on all FlightDelayed() as delayed {
			log "*** <DEBUG> DELAYED FLIGHT[" + delayed.flightID + "]  found ***" at INFO;
		}
		on all TravelHasConnectingFlightMatchEvent(): travelHasConnectingFlight {
			numberWorkingConnectingFlights := numberWorkingConnectingFlights + 1;
			log "*** CF-Travel[" + travelHasConnectingFlight.travelID + "] with Flight[" + travelHasConnectingFlight.flightID + 
			"]  found ***" at INFO;
			on all FlightDelayed(flightID=travelHasConnectingFlight.flightID) as flight {
				connectingFlightNotReachable(flight.arrival);
			}
			on all FlightOnTimeAgain(flightID=travelHasConnectingFlight.flightID) as flight {
				connectingFlightNotReachable(flight.arrival);
			}
			on all TravelHasNotReachableConnectingFlight(travelID=travelHasConnectingFlight.travelID, 
			                                           flightID=travelHasConnectingFlight.flightID)
					-> TravelHasReachableConnectingFlight(travelID=travelHasConnectingFlight.travelID, 
					                                           flightID=travelHasConnectingFlight.flightID) {
				numberDelayedConnectingFlights := numberDelayedConnectingFlights -1;
				numberWorkingConnectingFlights := numberWorkingConnectingFlights +1;
				send RemoveIssue(travelHasConnectingFlight.issueMatchID) to outputChannel;
			}
			on all TravelHasReachableConnectingFlight(travelID=travelHasConnectingFlight.travelID, 
				                                           flightID=travelHasConnectingFlight.flightID)
						-> TravelHasNotReachableConnectingFlight(travelID=travelHasConnectingFlight.travelID, 
						                                           flightID=travelHasConnectingFlight.flightID) {
				numberDelayedConnectingFlights := numberDelayedConnectingFlights +1;
				numberWorkingConnectingFlights := numberWorkingConnectingFlights -1;
				send Issue(travelHasConnectingFlight.issueMatchID, "*** Travel[" + travelHasConnectingFlight.travelID + "]:
				           Flight[" + travelHasConnectingFlight.connectingFlightID + 
				           "] is not reachable ***") to outputChannel;
			}
		}
	}
	/**
	 *  Actions for listener in 'onload'
	 */
	action connectingFlightNotReachable(integer flightArrival) {
		isReach := isReachable(travelHasConnectingFlight.arrivalGatePosition, travelHasConnectingFlight.departingGatePosition,
	                 travelHasConnectingFlight.connectingFlightDeparture,
	                 flightArrival, travelHasConnectingFlight.transitAirportSize);
		log "cFNR " + travelHasConnectingFlight.flightID + " is reachable? " + isReach.toString() at INFO;
		if (not isReach){
			log "*** Travel[" + travelHasConnectingFlight.travelID + "]: Flight[" + travelHasConnectingFlight.connectingFlightID + 
				"] is not reachable ***" at INFO;
			route TravelHasNotReachableConnectingFlight(travelHasConnectingFlight.travelID,travelHasConnectingFlight.flightID,travelHasConnectingFlight.connectingFlightID);
//				log "*** Travel[" + travelHasConnectingFlight.travelID + "]: Best connecting-flight-alternative: Flight["
//				+ alternativeForConnectingFlightDict[travelHasConnectingFlight.travelID].replacementFlightID + 
//					"] is not reachable ***" at INFO;
		} else {
			// TODO: Reachable again
			route TravelHasReachableConnectingFlight(travelHasConnectingFlight.travelID,travelHasConnectingFlight.flightID,travelHasConnectingFlight.connectingFlightID);
			log "*** Travel[" + travelHasConnectingFlight.travelID + "]: Flight[" + travelHasConnectingFlight.connectingFlightID + 
				"]  is reachable again ***" at INFO;
		}
	}
	action checkDelayedFlight() {
		// log "cDF" at INFO;
		log "*** Flight[" + flightWithRoute.flightID + "] found ***" at INFO;
		if (flightWithRoute.fligthArrival > flightWithRoute.flightDeparture + flightWithRoute.routeDuration) {
			route FlightDelayed(flightWithRoute.flightID, flightWithRoute.fligthArrival);
			log "*** Flight[" + flightWithRoute.flightID + "] is delayed ***" at INFO; 
		} else {
			route FlightOnTimeAgain(flightWithRoute.flightID, flightWithRoute.fligthArrival);
			log "*** Flight[" + flightWithRoute.flightID + "] is on time ***" at INFO;
		}
	}
	action isReachable(integer arrivalGatePosition, integer departingGatePosition,
	       integer connectingFlightDeparture, integer flightArrival, float transitAirportSize) returns boolean {
		// log "iR" at INFO;
		integer abs:=0;
		if((arrivalGatePosition - departingGatePosition)<0) {
			abs:= (departingGatePosition - arrivalGatePosition);
		} else {
			abs:=(arrivalGatePosition - departingGatePosition);
		}
		return connectingFlightDeparture.toFloat() >= (flightArrival.toFloat()
				+ abs.toFloat() * transitAirportSize);
	}
	action addPersonToFlight(string flightID, integer planeCapacity, integer numPersons) {
		// log "aPTF" at INFO;
		integer personsOnFlight := 0;
		if(not flightCapacityDict.hasKey(flightID) ) {
			flightCapacityDict[flightID] := planeCapacity;
		}
		if(personsOnFlightDict.hasKey(flightID)) {
			personsOnFlight := personsOnFlightDict[flightID];
		}
		personsOnFlight := personsOnFlight+numPersons;
		personsOnFlightDict[flightID] := personsOnFlight;
		
		integer spacesLeft := flightCapacityDict[flightID] - personsOnFlight;
		
		
		
		if(personsOnFlight >= flightCapacityDict[flightID]) {
			route FlightIsFull(flightID);
			log "*** Flight[" + flightID + "] has " + spacesLeft.toString() + " is full ***" at INFO;
		} else {
			route FlightHasFreeSpaces(flightID);
		}
	}
	action removePersonFromFlight(string flightID, integer numPersons) {
		addPersonToFlight(flightID,0,-numPersons);
	}
	action updateAlternative() {			
			// log "uA" at INFO;
			if(isReachable(travelHasConnectingFlight.arrivalGatePosition,
		               connectingFlightAlternative.replacementFlightDepartingGatePosition,
		               connectingFlightAlternative.replacementFlightDeparture,
		               travelHasConnectingFlight.flightArrival,
		               travelHasConnectingFlight.transitAirportSize)) {
				if (serviceLevel=2) {
					log "*** Flight[" + connectingFlightAlternative.replacementFlightID + "] is an alternative for ConnectingFlight["
					+ connectingFlightAlternative.connectingFlightID + "] of Travel[" + travelHasConnectingFlight.travelID + "] ***" at INFO;
				}
				send Solution(connectingFlightAlternative.solutionMatchID,travelHasConnectingFlight.issueMatchID) to outputChannel;
				if((not alternativeForConnectingFlightDict.hasKey(travelHasConnectingFlight.connectingFlightID)
				     or connectingFlightAlternative.replacementFlightArrival < 
				     alternativeForConnectingFlightDict[travelHasConnectingFlight.connectingFlightID].replacementFlightArrival)) {
				alternativeForConnectingFlightDict[travelHasConnectingFlight.connectingFlightID] := connectingFlightAlternative;
			}
		}
	}
}